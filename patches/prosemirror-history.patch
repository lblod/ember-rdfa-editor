diff --git a/dist/index.cjs b/dist/index.cjs
index e0e1020d3a68c383dd393741a50fc61efe9af068..e56f1f969e350cb0efe2a5edd3cdfa8c129417a4 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -1,11 +1,11 @@
 'use strict';
 
 function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
-function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
-function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
-function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
-function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
-function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
+function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
+function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
+function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
 var RopeSequence = require('rope-sequence');
 var prosemirrorTransform = require('prosemirror-transform');
 var prosemirrorState = require('prosemirror-state');
@@ -16,7 +16,7 @@ var Branch = function () {
     this.items = items;
     this.eventCount = eventCount;
   }
-  _createClass(Branch, [{
+  return _createClass(Branch, [{
     key: "popEvent",
     value: function popEvent(state, preserveItems) {
       var _this = this;
@@ -34,7 +34,8 @@ var Branch = function () {
         remap = this.remapping(end, this.items.length);
         mapFrom = remap.maps.length;
       }
-      var transform = state.tr;
+      var transform = state.tr,
+        poppedId;
       var selection, remaining;
       var addAfter = [],
         addBefore = [];
@@ -64,25 +65,27 @@ var Branch = function () {
         if (item.selection) {
           selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
           remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);
+          poppedId = item.id;
           return false;
         }
       }, this.items.length, 0);
       return {
         remaining: remaining,
         transform: transform,
-        selection: selection
+        selection: selection,
+        itemId: poppedId
       };
     }
   }, {
     key: "addTransform",
-    value: function addTransform(transform, selection, histOptions, preserveItems) {
+    value: function addTransform(transform, selection, histOptions, preserveItems, itemId) {
       var newItems = [],
         eventCount = this.eventCount;
       var oldItems = this.items,
         lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
       for (var i = 0; i < transform.steps.length; i++) {
         var step = transform.steps[i].invert(transform.docs[i]);
-        var item = new Item(transform.mapping.maps[i], step, selection),
+        var item = new Item(transform.mapping.maps[i], step, selection, undefined, itemId),
           merged = void 0;
         if (merged = lastItem && lastItem.merge(item)) {
           item = merged;
@@ -195,7 +198,6 @@ var Branch = function () {
       return new Branch(RopeSequence.from(items.reverse()), events);
     }
   }]);
-  return Branch;
 }();
 Branch.empty = new Branch(RopeSequence.empty, 0);
 function cutOffEvents(items, n) {
@@ -209,14 +211,15 @@ function cutOffEvents(items, n) {
   return items.slice(cutPoint);
 }
 var Item = function () {
-  function Item(map, step, selection, mirrorOffset) {
+  function Item(map, step, selection, mirrorOffset, id) {
     _classCallCheck(this, Item);
     this.map = map;
     this.step = step;
     this.selection = selection;
     this.mirrorOffset = mirrorOffset;
+    this.id = id !== null && id !== void 0 ? id : "".concat(Date.now());
   }
-  _createClass(Item, [{
+  return _createClass(Item, [{
     key: "merge",
     value: function merge(other) {
       if (this.step && other.step && !other.selection) {
@@ -225,7 +228,6 @@ var Item = function () {
       }
     }
   }]);
-  return Item;
 }();
 var HistoryState = _createClass(function HistoryState(done, undone, prevRanges, prevTime, prevComposition) {
   _classCallCheck(this, HistoryState);
@@ -289,7 +291,7 @@ function histTransaction(history, state, redo) {
   var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
   if (!pop) return null;
   var selection = pop.selection.resolve(pop.transform.doc);
-  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
+  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems, pop.itemId);
   var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);
   return pop.transform.setSelection(selection).setMeta(historyKey, {
     redo: redo,
@@ -371,9 +373,21 @@ function redoDepth(state) {
 function isHistoryTransaction(tr) {
   return tr.getMeta(historyKey) != null;
 }
+function getHistoryStateId(state) {
+  var _a;
+  var hist = historyKey.getState(state);
+  if (!hist || hist.done.eventCount === 0) return;
+  var items = hist.done.items;
+  return (_a = items.get(items.length - 1)) === null || _a === void 0 ? void 0 : _a.id;
+}
+function matchesTaggedHistory(state, id) {
+  return getHistoryStateId(state) === id;
+}
 exports.closeHistory = closeHistory;
+exports.getHistoryStateId = getHistoryStateId;
 exports.history = history;
 exports.isHistoryTransaction = isHistoryTransaction;
+exports.matchesTaggedHistory = matchesTaggedHistory;
 exports.redo = redo;
 exports.redoDepth = redoDepth;
 exports.redoNoScroll = redoNoScroll;
diff --git a/dist/index.d.cts b/dist/index.d.cts
index ba077f149426e8a0fc53ef4b42f3aa219d65ffc0..70aa2a0653804f40107c774083339ac8a7120a1d 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -1,4 +1,4 @@
-import { Transaction, Plugin, Command, EditorState } from 'prosemirror-state';
+import { Transaction, EditorState, Plugin, Command } from 'prosemirror-state';
 
 /**
 Set a flag on the given transaction that will prevent further steps
@@ -60,5 +60,16 @@ Returns true if the given transaction was generated by the history
 plugin.
 */
 declare function isHistoryTransaction(tr: Transaction): boolean;
+/**
+Returns the unique ID of the current history for a given editor state.
+This can for example be used to compare against a saved state, to
+determine if there are changes since then.
+*/
+declare function getHistoryStateId(state: EditorState): string | undefined;
+/**
+Whether the unique IDs of the history for the given editor state matches
+the passed ID.
+*/
+declare function matchesTaggedHistory(state: EditorState, id: string): boolean;
 
-export { closeHistory, history, isHistoryTransaction, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
+export { closeHistory, getHistoryStateId, history, isHistoryTransaction, matchesTaggedHistory, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
diff --git a/dist/index.d.ts b/dist/index.d.ts
index ba077f149426e8a0fc53ef4b42f3aa219d65ffc0..70aa2a0653804f40107c774083339ac8a7120a1d 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,4 +1,4 @@
-import { Transaction, Plugin, Command, EditorState } from 'prosemirror-state';
+import { Transaction, EditorState, Plugin, Command } from 'prosemirror-state';
 
 /**
 Set a flag on the given transaction that will prevent further steps
@@ -60,5 +60,16 @@ Returns true if the given transaction was generated by the history
 plugin.
 */
 declare function isHistoryTransaction(tr: Transaction): boolean;
+/**
+Returns the unique ID of the current history for a given editor state.
+This can for example be used to compare against a saved state, to
+determine if there are changes since then.
+*/
+declare function getHistoryStateId(state: EditorState): string | undefined;
+/**
+Whether the unique IDs of the history for the given editor state matches
+the passed ID.
+*/
+declare function matchesTaggedHistory(state: EditorState, id: string): boolean;
 
-export { closeHistory, history, isHistoryTransaction, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
+export { closeHistory, getHistoryStateId, history, isHistoryTransaction, matchesTaggedHistory, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
diff --git a/dist/index.js b/dist/index.js
index acd29d912b20016ae4f59fdce72c110a3a3dfcfd..87da4cd7a5a46f1bece40e235cd3da59d024e097 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -42,7 +42,7 @@ class Branch {
             remap = this.remapping(end, this.items.length);
             mapFrom = remap.maps.length;
         }
-        let transform = state.tr;
+        let transform = state.tr, poppedId;
         let selection, remaining;
         let addAfter = [], addBefore = [];
         this.items.forEach((item, i) => {
@@ -72,18 +72,19 @@ class Branch {
             if (item.selection) {
                 selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
                 remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
+                poppedId = item.id;
                 return false;
             }
         }, this.items.length, 0);
-        return { remaining: remaining, transform, selection: selection };
+        return { remaining: remaining, transform, selection: selection, itemId: poppedId };
     }
     // Create a new branch with the given transform added.
-    addTransform(transform, selection, histOptions, preserveItems) {
+    addTransform(transform, selection, histOptions, preserveItems, itemId) {
         let newItems = [], eventCount = this.eventCount;
         let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
         for (let i = 0; i < transform.steps.length; i++) {
             let step = transform.steps[i].invert(transform.docs[i]);
-            let item = new Item(transform.mapping.maps[i], step, selection), merged;
+            let item = new Item(transform.mapping.maps[i], step, selection, undefined, itemId), merged;
             if (merged = lastItem && lastItem.merge(item)) {
                 item = merged;
                 if (i)
@@ -227,11 +228,12 @@ class Item {
     selection, 
     // If this item is the inverse of a previous mapping on the stack,
     // this points at the inverse's offset
-    mirrorOffset) {
+    mirrorOffset, id) {
         this.map = map;
         this.step = step;
         this.selection = selection;
         this.mirrorOffset = mirrorOffset;
+        this.id = id !== null && id !== void 0 ? id : `${Date.now()}`;
     }
     merge(other) {
         if (this.step && other.step && !other.selection) {
@@ -328,7 +330,7 @@ function histTransaction(history, state, redo) {
     if (!pop)
         return null;
     let selection = pop.selection.resolve(pop.transform.doc);
-    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
+    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems, pop.itemId);
     let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);
     return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });
 }
@@ -449,5 +451,25 @@ plugin.
 function isHistoryTransaction(tr) {
     return tr.getMeta(historyKey) != null;
 }
+/**
+Returns the unique ID of the current history for a given editor state.
+This can for example be used to compare against a saved state, to
+determine if there are changes since then.
+*/
+function getHistoryStateId(state) {
+    var _a;
+    let hist = historyKey.getState(state);
+    if (!hist || hist.done.eventCount === 0)
+        return;
+    let items = hist.done.items;
+    return (_a = items.get(items.length - 1)) === null || _a === void 0 ? void 0 : _a.id;
+}
+/**
+Whether the unique IDs of the history for the given editor state matches
+the passed ID.
+*/
+function matchesTaggedHistory(state, id) {
+    return getHistoryStateId(state) === id;
+}
 
-export { closeHistory, history, isHistoryTransaction, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
+export { closeHistory, getHistoryStateId, history, isHistoryTransaction, matchesTaggedHistory, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
diff --git a/src/history.ts b/src/history.ts
index 3334b83aac908ca818159336c8507056bbf4766a..f43652fa80e41f73f31b594ec0586005b557dbd4 100644
--- a/src/history.ts
+++ b/src/history.ts
@@ -40,7 +40,7 @@ class Branch {
       remap = this.remapping(end, this.items.length)
       mapFrom = remap.maps.length
     }
-    let transform = state.tr
+    let transform = state.tr, poppedId: string | undefined
     let selection: SelectionBookmark | undefined, remaining: Branch | undefined
     let addAfter: Item[] = [], addBefore: Item[] = []
 
@@ -72,22 +72,23 @@ class Branch {
       if (item.selection) {
         selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection
         remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)
+        poppedId = item.id
         return false
       }
     }, this.items.length, 0)
 
-    return {remaining: remaining!, transform, selection: selection!}
+    return {remaining: remaining!, transform, selection: selection!, itemId: poppedId}
   }
 
   // Create a new branch with the given transform added.
   addTransform(transform: Transform, selection: SelectionBookmark | undefined,
-               histOptions: Required<HistoryOptions>, preserveItems: boolean) {
+               histOptions: Required<HistoryOptions>, preserveItems: boolean, itemId?: string) {
     let newItems = [], eventCount = this.eventCount
     let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null
 
     for (let i = 0; i < transform.steps.length; i++) {
       let step = transform.steps[i].invert(transform.docs[i])
-      let item = new Item(transform.mapping.maps[i], step, selection), merged
+      let item = new Item(transform.mapping.maps[i], step, selection, undefined, itemId), merged
       if (merged = lastItem && lastItem.merge(item)) {
         item = merged
         if (i) newItems.pop()
@@ -218,6 +219,8 @@ function cutOffEvents(items: RopeSequence<Item>, n: number) {
 }
 
 class Item {
+  readonly id: string
+
   constructor(
     // The (forward) step map for this item.
     readonly map: StepMap,
@@ -229,8 +232,11 @@ class Item {
     readonly selection?: SelectionBookmark,
     // If this item is the inverse of a previous mapping on the stack,
     // this points at the inverse's offset
-    readonly mirrorOffset?: number
-  ) {}
+    readonly mirrorOffset?: number,
+    id?: string,
+  ) {
+    this.id = id ?? `${Date.now()}`
+  }
 
   merge(other: Item) {
     if (this.step && other.step && !other.selection) {
@@ -336,7 +342,7 @@ function histTransaction(history: HistoryState, state: EditorState, redo: boolea
 
   let selection = pop.selection!.resolve(pop.transform.doc)
   let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),
-                                                                  histOptions, preserveItems)
+                                                                  histOptions, preserveItems, pop.itemId)
 
   let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1)
   return pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist})
@@ -463,3 +469,19 @@ export function redoDepth(state: EditorState) {
 export function isHistoryTransaction(tr: Transaction) {
   return tr.getMeta(historyKey) != null
 }
+
+/// Returns the unique ID of the current history for a given editor state.
+/// This can for example be used to compare against a saved state, to
+/// determine if there are changes since then.
+export function getHistoryStateId(state: EditorState): string | undefined {
+  let hist: HistoryState | undefined = historyKey.getState(state)
+  if (!hist || hist.done.eventCount === 0) return
+  let items = hist.done.items
+  return items.get(items.length - 1)?.id
+}
+
+/// Whether the unique IDs of the history for the given editor state matches
+/// the passed ID.
+export function matchesTaggedHistory(state: EditorState, id: string) {
+  return getHistoryStateId(state) === id
+}
