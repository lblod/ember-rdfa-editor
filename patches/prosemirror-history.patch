diff --git a/dist/index.d.ts b/dist/index.d.ts
index ba077f149426e8a0fc53ef4b42f3aa219d65ffc0..70aa2a0653804f40107c774083339ac8a7120a1d 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,4 +1,4 @@
-import { Transaction, Plugin, Command, EditorState } from 'prosemirror-state';
+import { Transaction, EditorState, Plugin, Command } from 'prosemirror-state';
 
 /**
 Set a flag on the given transaction that will prevent further steps
@@ -60,5 +60,16 @@ Returns true if the given transaction was generated by the history
 plugin.
 */
 declare function isHistoryTransaction(tr: Transaction): boolean;
+/**
+Returns the unique ID of the current history for a given editor state.
+This can for example be used to compare against a saved state, to
+determine if there are changes since then.
+*/
+declare function getHistoryStateId(state: EditorState): string | undefined;
+/**
+Whether the unique IDs of the history for the given editor state matches
+the passed ID.
+*/
+declare function matchesTaggedHistory(state: EditorState, id: string): boolean;
 
-export { closeHistory, history, isHistoryTransaction, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
+export { closeHistory, getHistoryStateId, history, isHistoryTransaction, matchesTaggedHistory, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };
diff --git a/src/history.ts b/src/history.ts
index 3334b83aac908ca818159336c8507056bbf4766a..f43652fa80e41f73f31b594ec0586005b557dbd4 100644
--- a/src/history.ts
+++ b/src/history.ts
@@ -40,7 +40,7 @@ class Branch {
       remap = this.remapping(end, this.items.length)
       mapFrom = remap.maps.length
     }
-    let transform = state.tr
+    let transform = state.tr, poppedId: string | undefined
     let selection: SelectionBookmark | undefined, remaining: Branch | undefined
     let addAfter: Item[] = [], addBefore: Item[] = []
 
@@ -72,22 +72,23 @@ class Branch {
       if (item.selection) {
         selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection
         remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)
+        poppedId = item.id
         return false
       }
     }, this.items.length, 0)
 
-    return {remaining: remaining!, transform, selection: selection!}
+    return {remaining: remaining!, transform, selection: selection!, itemId: poppedId}
   }
 
   // Create a new branch with the given transform added.
   addTransform(transform: Transform, selection: SelectionBookmark | undefined,
-               histOptions: Required<HistoryOptions>, preserveItems: boolean) {
+               histOptions: Required<HistoryOptions>, preserveItems: boolean, itemId?: string) {
     let newItems = [], eventCount = this.eventCount
     let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null
 
     for (let i = 0; i < transform.steps.length; i++) {
       let step = transform.steps[i].invert(transform.docs[i])
-      let item = new Item(transform.mapping.maps[i], step, selection), merged
+      let item = new Item(transform.mapping.maps[i], step, selection, undefined, itemId), merged
       if (merged = lastItem && lastItem.merge(item)) {
         item = merged
         if (i) newItems.pop()
@@ -218,6 +219,8 @@ function cutOffEvents(items: RopeSequence<Item>, n: number) {
 }
 
 class Item {
+  readonly id: string
+
   constructor(
     // The (forward) step map for this item.
     readonly map: StepMap,
@@ -229,8 +232,11 @@ class Item {
     readonly selection?: SelectionBookmark,
     // If this item is the inverse of a previous mapping on the stack,
     // this points at the inverse's offset
-    readonly mirrorOffset?: number
-  ) {}
+    readonly mirrorOffset?: number,
+    id?: string,
+  ) {
+    this.id = id ?? `${Date.now()}`
+  }
 
   merge(other: Item) {
     if (this.step && other.step && !other.selection) {
@@ -336,7 +342,7 @@ function histTransaction(history: HistoryState, state: EditorState, redo: boolea
 
   let selection = pop.selection!.resolve(pop.transform.doc)
   let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),
-                                                                  histOptions, preserveItems)
+                                                                  histOptions, preserveItems, pop.itemId)
 
   let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1)
   return pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist})
@@ -463,3 +469,19 @@ export function redoDepth(state: EditorState) {
 export function isHistoryTransaction(tr: Transaction) {
   return tr.getMeta(historyKey) != null
 }
+
+/// Returns the unique ID of the current history for a given editor state.
+/// This can for example be used to compare against a saved state, to
+/// determine if there are changes since then.
+export function getHistoryStateId(state: EditorState): string | undefined {
+  let hist: HistoryState | undefined = historyKey.getState(state)
+  if (!hist || hist.done.eventCount === 0) return
+  let items = hist.done.items
+  return items.get(items.length - 1)?.id
+}
+
+/// Whether the unique IDs of the history for the given editor state matches
+/// the passed ID.
+export function matchesTaggedHistory(state: EditorState, id: string) {
+  return getHistoryStateId(state) === id
+}
